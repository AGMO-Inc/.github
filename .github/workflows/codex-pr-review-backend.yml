name: Codex PR Review - Backend (Reusable)

on:
  workflow_call:
    inputs:
      model:
        description: "Model name for review (leave empty to use gpt-5.2-codex)"
        required: false
        type: string
        default: "gpt-5.2-codex"
      max_diff_bytes:
        description: "Limit diff size to avoid huge payloads"
        required: false
        type: number
        default: 180000
    secrets:
      CODEX_API_TOKEN:
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: read

jobs:
  review:
    runs-on: ubuntu-latest

    steps:
      - name: Check out PR merge commit
        uses: actions/checkout@v5
        with:
          ref: refs/pull/${{ github.event.pull_request.number }}/merge

      - name: Pre-fetch PR refs for local inspection
        run: |
          set -euo pipefail
          git fetch --no-tags origin \
            "${{ github.event.pull_request.base.ref }}" \
            "+refs/pull/${{ github.event.pull_request.number }}/head"

      - name: Fetch changed files summary
        id: changed_files
        env:
          GH_TOKEN: ${{ github.token }}
          MAX_DIFF_BYTES: ${{ inputs.max_diff_bytes }}
        run: |
          set -euo pipefail
          owner="${{ github.repository_owner }}"
          repo="$(echo "${{ github.repository }}" | cut -d/ -f2)"
          pr="${{ github.event.pull_request.number }}"

          curl -sS -L \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/${owner}/${repo}/pulls/${pr}/files?per_page=100" \
            > pr_files.json

          python - <<'PY'
          import json
          import os

          max_bytes = int(os.environ.get("MAX_DIFF_BYTES", "180000"))

          with open("pr_files.json", "r", encoding="utf-8") as handle:
            files = json.load(handle)

          total_add = 0
          total_del = 0
          lines = []
          for item in files:
            filename = item.get("filename", "")
            status = item.get("status", "modified")
            additions = int(item.get("additions", 0) or 0)
            deletions = int(item.get("deletions", 0) or 0)
            changes = int(item.get("changes", additions + deletions) or 0)
            total_add += additions
            total_del += deletions
            lines.append(f"- [{status}] {filename} (+{additions} -{deletions}, ~{changes})")

          body = "\n".join([
            "Changed files (summary):",
            f"- count: {len(files)}",
            f"- additions: {total_add}",
            f"- deletions: {total_del}",
            "",
            *lines,
            "",
          ])

          truncated = False
          encoded = body.encode("utf-8")
          if len(encoded) > max_bytes:
            body = encoded[:max_bytes].decode("utf-8", errors="ignore")
            body = body.rsplit("\n", 1)[0] + "\n...[truncated]\n"
            truncated = True

          with open("pr_files_summary.md", "w", encoding="utf-8") as out:
            out.write(body)

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as out:
            out.write(f"truncated={'true' if truncated else 'false'}\n")
            out.write(f"file_count={len(files)}\n")
          PY

      - name: Build Codex prompt and schema
        id: prompt
        env:
          GH_TOKEN: ${{ github.token }}
          REPO_FULL: ${{ github.repository }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_BODY: ${{ github.event.pull_request.body || '' }}
          FILES_SUMMARY_TRUNCATED: ${{ steps.changed_files.outputs.truncated }}
        run: |
          set -euo pipefail

          cat > codex_prompt.md <<'EOF'
          ë‹¹ì‹ ì€ í”„ë¡œì íŠ¸ì˜ ì‹œë‹ˆì–´ ë°±ì—”ë“œ ì½”ë“œ ë¦¬ë·°ì–´ë‹¤.

          ## ë°±ì—”ë“œ ë¦¬ë·° ê¸°ì¤€ (5 x 20 = 100)

          ### 1. ë³´ì•ˆ (0-20)
          - í•˜ë“œì½”ë”©ëœ ë¹„ë°€ê°’, API í‚¤, ì¸ì¦ì •ë³´ê°€ ì—†ì–´ì•¼ í•œë‹¤.
          - SQL ì¸ì ì…˜/ì»¤ë§¨ë“œ ì¸ì ì…˜ ìœ„í—˜ì´ ì—†ì–´ì•¼ í•œë‹¤.
          - API ê²½ê³„ì—ì„œ ì…ë ¥ ê²€ì¦ì´ ì ì ˆíˆ ìˆ˜í–‰ë˜ì–´ì•¼ í•œë‹¤.
          - ë¡œê·¸/ì—ëŸ¬ ë©”ì‹œì§€ì— ë¯¼ê°ì •ë³´ê°€ ë…¸ì¶œë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤.
          - ì¸ì¦/ì¸ê°€ êµ¬ì„±ì´ ì˜ë„ëŒ€ë¡œ ë™ì‘í•´ì•¼ í•œë‹¤.

          ### 2. ì½”ë“œ í’ˆì§ˆ (0-20)
          - Kotlin ì½”ë“œê°€ ì½ê¸° ì‰½ê³  í”„ë¡œì íŠ¸ ê·œì¹™ì„ ë”°ë¼ì•¼ í•œë‹¤.
          - ì—ëŸ¬ ì²˜ë¦¬ì™€ ì˜ˆì™¸ ê´€ë¦¬ê°€ ì¼ê´€ë˜ì–´ì•¼ í•œë‹¤.
          - í•¨ìˆ˜/í´ë˜ìŠ¤ì˜ ì±…ì„ì´ ê³¼ë„í•˜ê²Œ ì„ì´ì§€ ì•Šì•„ì•¼ í•œë‹¤.
          - Kotlin ê´€ìš©êµ¬ì™€ null ì•ˆì „ì„±ì´ ì ì ˆíˆ ì‚¬ìš©ë˜ì–´ì•¼ í•œë‹¤.
          - ë¶ˆí•„ìš”í•œ ë³µì¡ë„, ì¤‘ë³µ, ì£½ì€ ì½”ë“œê°€ ì—†ì–´ì•¼ í•œë‹¤.

          ### 3. ì•„í‚¤í…ì²˜ (0-20)
          - ë ˆì´ì–´/ì±…ì„ ë¶„ë¦¬ê°€ ê¸°ì¡´ ì•„í‚¤í…ì²˜ ì›ì¹™ê³¼ ì¼ì¹˜í•´ì•¼ í•œë‹¤.
          - ì˜ì¡´ì„± ë°©í–¥ê³¼ ê²½ê³„ê°€ ì˜¬ë°”ë¥´ê²Œ ìœ ì§€ë˜ì–´ì•¼ í•œë‹¤.
          - ìœ ìŠ¤ì¼€ì´ìŠ¤ì™€ ë„ë©”ì¸ ì±…ì„ì´ ëª…í™•í•´ì•¼ í•œë‹¤.
          - DTO/ì—”í‹°í‹° ê²½ê³„ê°€ ë¬´ë„ˆì§€ì§€ ì•Šì•„ì•¼ í•œë‹¤.
          - ê¸°ì¡´ ì½”ë“œë² ì´ìŠ¤ íŒ¨í„´ê³¼ ì¶©ëŒí•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤.

          ### 4. ì •í™•ì„± (0-20)
          - ë¡œì§ì´ ìš”êµ¬ì‚¬í•­ê³¼ ì—£ì§€ ì¼€ì´ìŠ¤ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì²˜ë¦¬í•´ì•¼ í•œë‹¤.
          - ëª…ë°±í•œ ë²„ê·¸/ëŸ°íƒ€ì„ ì˜¤ë¥˜ ê°€ëŠ¥ì„±ì´ ì—†ì–´ì•¼ í•œë‹¤.
          - API ê³„ì•½(ìš”ì²­/ì‘ë‹µ)ì´ ìœ ì§€ë˜ì–´ì•¼ í•œë‹¤.
          - DB ì¿¼ë¦¬/ë§¤í•‘/N+1 ìœ„í—˜ì´ ì ì ˆíˆ ê´€ë¦¬ë˜ì–´ì•¼ í•œë‹¤.
          - í™˜ê²½ë³„ ì„¤ì •ì´ ì˜ë„ëŒ€ë¡œ ë°˜ì˜ë˜ì–´ì•¼ í•œë‹¤.

          ### 5. ì„±ëŠ¥ ë° ë°ì´í„° (0-20)
          - ì¿¼ë¦¬/í˜ì´ì§•/ì¸ë±ìŠ¤ ë“± ë°ì´í„° ì ‘ê·¼ì´ íš¨ìœ¨ì ì´ì–´ì•¼ í•œë‹¤.
          - ìš”ì²­ ê²½ë¡œì—ì„œ ë¶ˆí•„ìš”í•œ ë¸”ë¡œí‚¹ ì‘ì—…ì´ ì—†ì–´ì•¼ í•œë‹¤.
          - ìºì‹œ/íŠ¸ëœì­ì…˜ ê²½ê³„ê°€ í•©ë¦¬ì ìœ¼ë¡œ ì„¤ì •ë˜ì–´ì•¼ í•œë‹¤.
          - ë¦¬ì†ŒìŠ¤ ì •ë¦¬(ì—°ê²°/ìŠ¤íŠ¸ë¦¼)ê°€ ëˆ„ë½ë˜ì§€ ì•Šì•„ì•¼ í•œë‹¤.

          ## ë³€ê²½ì‚¬í•­ í™•ì¸ ë°©ì‹ (í•„ìˆ˜)
          - ì „ì²´ íŒ¨ì¹˜ í…ìŠ¤íŠ¸ëŠ” ì œê³µë˜ì§€ ì•ŠëŠ”ë‹¤.
          - ë°˜ë“œì‹œ ì²´í¬ì•„ì›ƒëœ ì €ì¥ì†Œì—ì„œ ì§ì ‘ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•œë‹¤.
          - ìš°ì„  `git diff --name-only HEAD^1..HEAD`ë¡œ ë³€ê²½ íŒŒì¼ ëª©ë¡ì„ í™•ì¸í•œë‹¤.
          - í•„ìš”í•œ íŒŒì¼ì— í•œí•´ `git diff HEAD^1..HEAD -- <path>`ì™€ íŒŒì¼ ë‚´ìš©ì„ ì¡°íšŒí•œë‹¤.
          - ì•„ë˜ ìš”ì•½ëœ íŒŒì¼ ëª©ë¡ê³¼ ì§ì ‘ ì¡°íšŒ ê²°ê³¼ê°€ ë‹¤ë¥´ë©´ ì§ì ‘ ì¡°íšŒ ê²°ê³¼ë¥¼ ìš°ì„ í•œë‹¤.

          ---

          ## ì¶œë ¥ í˜•ì‹ (í•„ìˆ˜)

          ì•„ë˜ í˜•ì‹ì„ ë°˜ë“œì‹œ ê·¸ëŒ€ë¡œ ë”°ë¥¸ë‹¤.
          ê³„ì¸µì€ Markdown í—¤ë”ë¥¼ ì‚¬ìš©í•œë‹¤: H2(`##`) > H3(`###`).

          ```markdown
          ## ìš”ì•½
          - ì´ì : {5ê°œ ì ìˆ˜ í•©ê³„}/100
          - íŒì •: {í•©ê²© (ğŸŸ¢ O) if ì´ì  >= 80, ë¶ˆí•©ê²© (ğŸ”´ X) if ì´ì  < 80}
          - ì´í‰: {ì „ì²´ í‰ê°€ 1~2ë¬¸ì¥}

          ## 1. ë³´ì•ˆ
          ### ì ìˆ˜
          ì ìˆ˜: {number}/20
          ### ë¬¸ì œ
          - {ë¬¸ì œ ì„¤ëª…}
          ### í•´ê²° ë°©ë²•
          - {í•´ê²° ë°©ì•ˆ}
          ### ì˜ˆì‹œ
          ```kotlin
          {ì½”ë“œ ì˜ˆì‹œ ë˜ëŠ” "í•´ë‹¹ ì—†ìŒ"}
          ```

          ## 2. ì½”ë“œ í’ˆì§ˆ
          ### ì ìˆ˜
          ì ìˆ˜: {number}/20
          ### ë¬¸ì œ
          - {ë¬¸ì œ ì„¤ëª…}
          ### í•´ê²° ë°©ë²•
          - {í•´ê²° ë°©ì•ˆ}
          ### ì˜ˆì‹œ
          ```kotlin
          {ì½”ë“œ ì˜ˆì‹œ ë˜ëŠ” "í•´ë‹¹ ì—†ìŒ"}
          ```

          ## 3. ì•„í‚¤í…ì²˜
          ### ì ìˆ˜
          ì ìˆ˜: {number}/20
          ### ë¬¸ì œ
          - {ë¬¸ì œ ì„¤ëª…}
          ### í•´ê²° ë°©ë²•
          - {í•´ê²° ë°©ì•ˆ}
          ### ì˜ˆì‹œ
          ```kotlin
          {ì½”ë“œ ì˜ˆì‹œ ë˜ëŠ” "í•´ë‹¹ ì—†ìŒ"}
          ```

          ## 4. ì •í™•ì„±
          ### ì ìˆ˜
          ì ìˆ˜: {number}/20
          ### ë¬¸ì œ
          - {ë¬¸ì œ ì„¤ëª…}
          ### í•´ê²° ë°©ë²•
          - {í•´ê²° ë°©ì•ˆ}
          ### ì˜ˆì‹œ
          ```kotlin
          {ì½”ë“œ ì˜ˆì‹œ ë˜ëŠ” "í•´ë‹¹ ì—†ìŒ"}
          ```

          ## 5. ì„±ëŠ¥ ë° ë°ì´í„°
          ### ì ìˆ˜
          ì ìˆ˜: {number}/20
          ### ë¬¸ì œ
          - {ë¬¸ì œ ì„¤ëª…}
          ### í•´ê²° ë°©ë²•
          - {í•´ê²° ë°©ì•ˆ}
          ### ì˜ˆì‹œ
          ```kotlin
          {ì½”ë“œ ì˜ˆì‹œ ë˜ëŠ” "í•´ë‹¹ ì—†ìŒ"}
          ```
          ```

          ### ê·œì¹™
          1. ê° ì ìˆ˜ëŠ” 0~20ì˜ ì •ìˆ˜ë§Œ ì‚¬ìš©í•œë‹¤.
          2. ì´ì ì€ 5ê°œ ì ìˆ˜ì˜ ì •í™•í•œ í•©ì´ì–´ì•¼ í•œë‹¤.
          3. íŒì •ì€ ë°˜ë“œì‹œ `í•©ê²© (ğŸŸ¢ O)` ë˜ëŠ” `ë¶ˆí•©ê²© (ğŸ”´ X)`ë§Œ ì‚¬ìš©í•œë‹¤.
          4. ê° ì¹´í…Œê³ ë¦¬ì˜ `### ë¬¸ì œ`ëŠ” bullet ê¸°ì¤€ 0~3ê°œê¹Œì§€ ì‘ì„±í•œë‹¤.
          5. ë¬¸ì œê°€ ì—†ìœ¼ë©´ `- ì—†ìŒ` í•œ ì¤„ë§Œ ì‘ì„±í•œë‹¤.
          6. ê° ì¹´í…Œê³ ë¦¬ëŠ” `### ì ìˆ˜`, `### ë¬¸ì œ`, `### í•´ê²° ë°©ë²•`, `### ì˜ˆì‹œ`ë¥¼ ëª¨ë‘ í¬í•¨í•œë‹¤.
          7. 5ê°œ ì¹´í…Œê³ ë¦¬ H2 ì œëª©ì€ ë°˜ë“œì‹œ ë²ˆí˜¸ë¥¼ í¬í•¨í•œë‹¤ (`## 1. ë³´ì•ˆ` ~ `## 5. ì„±ëŠ¥ ë° ë°ì´í„°`).
          8. ìš”ì•½ì˜ `ì´ì `, `íŒì •`, `ì´í‰`ì€ ë°˜ë“œì‹œ `- ` ë¦¬ìŠ¤íŠ¸ í˜•íƒœë¡œ ì‘ì„±í•œë‹¤.
          9. ë¬¸ì œ/í•´ê²° ë°©ë²•ì€ ê°€ëŠ¥í•œ ê²½ìš° íŒŒì¼ ê²½ë¡œì™€ ë¼ì¸ ì •ë³´ë¥¼ í¬í•¨í•œë‹¤ (`path:line`).
          10. ì„¤ëª…ì€ í•œêµ­ì–´ë¡œ ì‘ì„±í•œë‹¤.
          EOF

          python - <<'PY'
          import json
          import os
          import urllib.request

          repo_full = os.environ.get("REPO_FULL", "")
          owner, repo = repo_full.split("/", 1)
          pr_number = int(os.environ["PR_NUMBER"])
          token = os.environ.get("GH_TOKEN", "")
          pr_body = (os.environ.get("PR_BODY") or "").strip()
          if not pr_body:
            pr_body = "None"
          elif len(pr_body) > 4000:
            pr_body = pr_body[:4000] + "\n...[truncated]"

          query = """
          query($owner: String!, $repo: String!, $number: Int!) {
            repository(owner: $owner, name: $repo) {
              pullRequest(number: $number) {
                closingIssuesReferences(first: 10) {
                  nodes {
                    number
                    title
                    url
                    state
                    bodyText
                  }
                }
              }
            }
          }
          """

          issue_nodes = []
          issue_lookup_error = ""
          try:
            req_body = json.dumps(
              {
                "query": query,
                "variables": {"owner": owner, "repo": repo, "number": pr_number},
              }
            ).encode("utf-8")
            req = urllib.request.Request(
              "https://api.github.com/graphql",
              data=req_body,
              headers={
                "Authorization": f"Bearer {token}",
                "Content-Type": "application/json",
                "Accept": "application/vnd.github+json",
              },
              method="POST",
            )
            with urllib.request.urlopen(req, timeout=20) as resp:
              payload = json.loads(resp.read().decode("utf-8", errors="replace"))
            issue_nodes = (
              payload.get("data", {})
              .get("repository", {})
              .get("pullRequest", {})
              .get("closingIssuesReferences", {})
              .get("nodes", [])
              or []
            )
          except Exception as exc:
            issue_lookup_error = str(exc)

          def one_line(text: str, limit: int) -> str:
            compact = " ".join((text or "").split())
            if not compact:
              return "N/A"
            if len(compact) > limit:
              return compact[:limit] + "..."
            return compact

          with open("pr_context.md", "w", encoding="utf-8") as out:
            out.write("PR body:\n")
            out.write(pr_body + "\n\n")
            out.write("Linked issues:\n")
            if issue_nodes:
              for node in issue_nodes:
                number = node.get("number")
                state = one_line(node.get("state", ""), 30)
                title = one_line(node.get("title", ""), 200)
                url = one_line(node.get("url", ""), 400)
                body = one_line(node.get("bodyText", ""), 240)
                out.write(f"- #{number} [{state}] {title} ({url})\n")
                out.write(f"  Context: {body}\n")
            else:
              if issue_lookup_error:
                out.write(f"- None (lookup failed: {one_line(issue_lookup_error, 160)})\n")
              else:
                out.write("- None\n")
          PY

          {
            echo ""
            echo "---"
            echo "PR number: ${PR_NUMBER}"
            echo "PR title: ${PR_TITLE}"
            echo "PR author: ${PR_AUTHOR}"
            echo "Changed files summary truncated: ${FILES_SUMMARY_TRUNCATED}"
            echo ""
            echo "PR body and linked issues:"
          } >> codex_prompt.md
          cat pr_context.md >> codex_prompt.md
          {
            echo ""
            echo "Changed files summary:"
          } >> codex_prompt.md
          cat pr_files_summary.md >> codex_prompt.md
          {
            echo ""
            echo "Workspace inspection reminder:"
            echo "- Review ONLY PR-introduced changes by inspecting local git/file context."
            echo "- Do not assume unchanged files are modified."
          } >> codex_prompt.md

      - name: Run Codex with selected model
        id: codex_model
        uses: openai/codex-action@v1
        continue-on-error: true
        with:
          openai-api-key: ${{ secrets.CODEX_API_TOKEN }}
          prompt-file: codex_prompt.md
          model: ${{ inputs.model || 'gpt-5.2-codex' }}
          sandbox: read-only
          safety-strategy: drop-sudo
          allow-bots: true

      - name: Run Codex with auto-selected model
        id: codex_auto
        if: ${{ steps.codex_model.outcome != 'success' }}
        uses: openai/codex-action@v1
        continue-on-error: true
        with:
          openai-api-key: ${{ secrets.CODEX_API_TOKEN }}
          prompt-file: codex_prompt.md
          sandbox: read-only
          safety-strategy: drop-sudo
          allow-bots: true

      - name: Prepare review output
        id: call
        env:
          CODEX_FINAL_MESSAGE: ${{ steps.codex_auto.outputs.final-message || steps.codex_model.outputs.final-message }}
          CODEX_OUTCOME: ${{ steps.codex_auto.outcome || steps.codex_model.outcome || 'failure' }}
          CODEX_MODEL_OUTCOME: ${{ steps.codex_model.outcome || 'skipped' }}
          CODEX_AUTO_OUTCOME: ${{ steps.codex_auto.outcome || 'skipped' }}
          REQUESTED_MODEL: ${{ inputs.model || 'gpt-5.2-codex' }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail

          python - <<'PY'
          import os, re

          raw = os.environ.get("CODEX_FINAL_MESSAGE") or ""
          outcome = os.environ.get("CODEX_OUTCOME") or ""
          model_outcome = os.environ.get("CODEX_MODEL_OUTCOME") or ""
          auto_outcome = os.environ.get("CODEX_AUTO_OUTCOME") or ""
          requested_model = os.environ.get("REQUESTED_MODEL") or ""
          run_url = os.environ.get("RUN_URL") or ""

          def fallback(reason: str) -> str:
            reason = reason.strip().replace("\n", " ")
            return "\n".join([
              "## ìš”ì•½",
              "- ì´ì : 0/100",
              "- íŒì •: ë¶ˆí•©ê²© (ğŸ”´ X)",
              "- ì´í‰: Codex ë¦¬ë·° ê²°ê³¼ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.",
              "",
              "## 1. ë³´ì•ˆ",
              "### ì ìˆ˜",
              "ì ìˆ˜: 0/20",
              "### ë¬¸ì œ",
              f"- {reason}",
              "### í•´ê²° ë°©ë²•",
              "- í•´ë‹¹ ì—†ìŒ",
              "### ì˜ˆì‹œ",
              "```text",
              "í•´ë‹¹ ì—†ìŒ",
              "```",
              "",
              "## 2. ì½”ë“œ í’ˆì§ˆ",
              "### ì ìˆ˜",
              "ì ìˆ˜: 0/20",
              "### ë¬¸ì œ",
              "- ì—†ìŒ",
              "### í•´ê²° ë°©ë²•",
              "- í•´ë‹¹ ì—†ìŒ",
              "### ì˜ˆì‹œ",
              "```text",
              "í•´ë‹¹ ì—†ìŒ",
              "```",
              "",
              "## 3. ì•„í‚¤í…ì²˜",
              "### ì ìˆ˜",
              "ì ìˆ˜: 0/20",
              "### ë¬¸ì œ",
              "- ì—†ìŒ",
              "### í•´ê²° ë°©ë²•",
              "- í•´ë‹¹ ì—†ìŒ",
              "### ì˜ˆì‹œ",
              "```text",
              "í•´ë‹¹ ì—†ìŒ",
              "```",
              "",
              "## 4. ì •í™•ì„±",
              "### ì ìˆ˜",
              "ì ìˆ˜: 0/20",
              "### ë¬¸ì œ",
              "- ì—†ìŒ",
              "### í•´ê²° ë°©ë²•",
              "- í•´ë‹¹ ì—†ìŒ",
              "### ì˜ˆì‹œ",
              "```text",
              "í•´ë‹¹ ì—†ìŒ",
              "```",
              "",
              "## 5. ì„±ëŠ¥ ë° ë°ì´í„°",
              "### ì ìˆ˜",
              "ì ìˆ˜: 0/20",
              "### ë¬¸ì œ",
              "- ì—†ìŒ",
              "### í•´ê²° ë°©ë²•",
              "- í•´ë‹¹ ì—†ìŒ",
              "### ì˜ˆì‹œ",
              "```text",
              "í•´ë‹¹ ì—†ìŒ",
              "```",
              "",
            ])

          def is_valid_template(s: str) -> tuple[bool, str]:
            required_h2 = ["ìš”ì•½", "1. ë³´ì•ˆ", "2. ì½”ë“œ í’ˆì§ˆ", "3. ì•„í‚¤í…ì²˜", "4. ì •í™•ì„±", "5. ì„±ëŠ¥ ë° ë°ì´í„°"]
            for section in required_h2:
              if f"## {section}" not in s:
                return False, f"Missing H2 section: {section}"

            score_re = re.compile(r"^ì ìˆ˜:\s*(\d{1,2})/20\s*$", re.MULTILINE)
            scores = [int(x) for x in score_re.findall(s)]
            if len(scores) < 5:
              return False, f"Expected 5 ì ìˆ˜ lines, found {len(scores)}"
            scores = scores[:5]
            if any(x < 0 or x > 20 for x in scores):
              return False, "Score out of range"

            m_total = re.search(r"^- ì´ì :\s*(\d{1,3})/100\s*$", s, re.MULTILINE)
            if not m_total:
              return False, "Missing ì´ì  line"
            total = int(m_total.group(1))
            if total != sum(scores):
              return False, f"ì´ì  mismatch (got {total}, expected {sum(scores)})"

            m_verdict = re.search(r"^- íŒì •:\s*(í•©ê²©|ë¶ˆí•©ê²©)\s*\(([^)]+)\)\s*$", s, re.MULTILINE)
            if not m_verdict:
              return False, "Missing íŒì • line"
            verdict = m_verdict.group(1)
            marker = m_verdict.group(2).strip()
            expected = "í•©ê²©" if total >= 80 else "ë¶ˆí•©ê²©"
            if verdict != expected:
              return False, f"íŒì • mismatch (got {verdict}, expected {expected})"
            expected_marker = "ğŸŸ¢ O" if expected == "í•©ê²©" else "ğŸ”´ X"
            if marker != expected_marker:
              return False, f"íŒì • marker mismatch (got {marker}, expected {expected_marker})"

            if not re.search(r"^- ì´í‰:\s*.+$", s, re.MULTILINE):
              return False, "Missing ì´í‰ line"

            section_names = ["1. ë³´ì•ˆ", "2. ì½”ë“œ í’ˆì§ˆ", "3. ì•„í‚¤í…ì²˜", "4. ì •í™•ì„±", "5. ì„±ëŠ¥ ë° ë°ì´í„°"]
            for section in section_names:
              m_section = re.search(
                rf"## {re.escape(section)}\n(?P<body>.*?)(?=\n## |\Z)",
                s,
                re.DOTALL,
              )
              if not m_section:
                return False, f"Missing section body: {section}"
              body = m_section.group("body")
              for required_h3 in ["### ì ìˆ˜", "### ë¬¸ì œ", "### í•´ê²° ë°©ë²•", "### ì˜ˆì‹œ"]:
                if required_h3 not in body:
                  return False, f"Missing {required_h3} in {section}"

              try:
                issues_part = body.split("### ë¬¸ì œ\n", 1)[1].split("\n### í•´ê²° ë°©ë²•", 1)[0]
              except Exception:
                return False, f"Cannot parse ë¬¸ì œ block in {section}"

              issue_lines = [ln.strip() for ln in issues_part.splitlines() if ln.strip().startswith("- ")]
              if not issue_lines:
                return False, f"ë¬¸ì œ bullet missing in {section}"
              if issue_lines == ["- ì—†ìŒ"]:
                pass
              else:
                if any(ln == "- ì—†ìŒ" for ln in issue_lines):
                  return False, f"ë¬¸ì œ block mixes 'ì—†ìŒ' with other issues in {section}"
                if len(issue_lines) > 3:
                  return False, f"ë¬¸ì œ bullet count exceeds 3 in {section}"

            return True, ""

          if not raw.strip():
            if requested_model:
              reason = f"Codex produced no output. requested_model={requested_model}, model_outcome={model_outcome}, auto_outcome={auto_outcome}, outcome={outcome}. Logs: {run_url}"
            else:
              reason = f"Codex produced no output. auto_outcome={auto_outcome}, outcome={outcome}. Logs: {run_url}"
            out = fallback(reason)
            ok = False
          else:
            valid, why = is_valid_template(raw)
            if not valid:
              out = fallback(f"Codex output invalid: {why}. Logs: {run_url}")
              ok = False
            else:
              out = raw.strip() + "\n"
              ok = True

          open("comment.md", "w", encoding="utf-8").write(out)
          open(os.environ.get("GITHUB_OUTPUT"), "a", encoding="utf-8").write(f"api_ok={'true' if ok else 'false'}\n")
          PY

      - name: Post PR comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          owner="${{ github.repository_owner }}"
          repo="$(echo "${{ github.repository }}" | cut -d/ -f2)"
          pr="${{ github.event.pull_request.number }}"

          python - <<'PY' > body.json
          import json
          body = open("comment.md", "r", encoding="utf-8", errors="replace").read()
          print(json.dumps({"body": body}))
          PY

          curl -sS -L \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -d @body.json \
            "https://api.github.com/repos/${owner}/${repo}/issues/${pr}/comments" \
            > /dev/null

      - name: Fail job if Codex failed
        if: ${{ steps.call.outputs.api_ok != 'true' }}
        run: |
          set -euo pipefail
          echo "Codex review failed. See the PR comment and job logs for details." >&2
          exit 1
