name: Codex PR Review - Backend (Reusable)

on:
  workflow_call:
    inputs:
      model:
        description: "Model name for review (leave empty to use gpt-5.2-codex)"
        required: false
        type: string
        default: "gpt-5.2-codex"
      max_diff_bytes:
        description: "Limit diff size to avoid huge payloads"
        required: false
        type: number
        default: 180000
    secrets:
      CODEX_API_TOKEN:
        required: true

permissions:
  contents: read
  pull-requests: write

jobs:
  review:
    runs-on: ubuntu-latest

    steps:
      - name: Check out PR merge commit
        uses: actions/checkout@v5
        with:
          ref: refs/pull/${{ github.event.pull_request.number }}/merge

      - name: Fetch PR diff
        id: diff
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          owner="${{ github.repository_owner }}"
          repo="$(echo "${{ github.repository }}" | cut -d/ -f2)"
          pr="${{ github.event.pull_request.number }}"

          curl -sS -L \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3.diff" \
            "https://api.github.com/repos/${owner}/${repo}/pulls/${pr}" \
            > pr.diff

          max="${{ inputs.max_diff_bytes }}"
          size=$(wc -c < pr.diff | tr -d ' ')
          if [ "$size" -gt "$max" ]; then
            head -c "$max" pr.diff > pr.diff.trunc
            mv pr.diff.trunc pr.diff
            echo "truncated=true" >> "$GITHUB_OUTPUT"
          else
            echo "truncated=false" >> "$GITHUB_OUTPUT"
          fi

          echo "diff_path=pr.diff" >> "$GITHUB_OUTPUT"

      - name: Build Codex prompt and schema
        id: prompt
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          DIFF_TRUNCATED: ${{ steps.diff.outputs.truncated }}
        run: |
          set -euo pipefail

          cat > codex_prompt.md <<'EOF'
          You are a senior code reviewer for the project

          ## Backend Review Criteria (5 × 20 = 100)

          ### 1. Security (0-20)
          - No hardcoded secrets, API keys, or credentials
          - No SQL injection or command injection vulnerabilities
          - Proper input validation at API boundaries (@Valid, Bean Validation)
          - No sensitive data exposure in logs or error messages
          - Authentication/authorization configured correctly (Spring Security, JWT)

          ### 2. Code Quality (0-20)
          - Clean, readable Kotlin code following project conventions
          - Proper error handling and exception management (sealed class, Result)
          - Functions and classes have single responsibility
          - Kotlin idioms used appropriately (data class, extension functions, null safety)
          - No unnecessary complexity, dead code, or code duplication

          ### 3. Architecture (0-20)
          - Hexagonal Architecture compliance (port/adapter separation)
          - Dependencies point inward (infrastructure → application → domain)
          - Use cases are clearly defined and isolated in application layer
          - DTOs used at boundaries — entities not exposed to controllers
          - Changes are consistent with existing patterns and layer conventions

          ### 4. Correctness (0-20)
          - Logic is correct and handles edge cases
          - No obvious bugs or runtime errors
          - API contracts (request/response DTOs) are properly maintained
          - Database queries are correct (JPA mappings, lazy loading, N+1)
          - Environment-specific configurations are correct

          ### 5. Performance & Data (0-20)
          - Database queries are efficient (indexes, pagination, batch operations)
          - No unnecessary blocking calls in request handling
          - Proper caching strategy where applicable
          - Transaction boundaries are appropriate (@Transactional scope)
          - Resource cleanup (connections, streams) handled correctly

          ---

          ## OUTPUT FORMAT (MANDATORY)

          You MUST follow this EXACT format. Category names change per role (see below).

          ### Backend Output

          ```
          [REVIEW_START]

          [SECURITY]
          SCORE: {number}/20
          ISSUES:
          - {issue description or "None"}
          RECOMMENDATION: {one-line recommendation or "N/A"}

          [CODE_QUALITY]
          SCORE: {number}/20
          ISSUES:
          - {issue description or "None"}
          RECOMMENDATION: {one-line recommendation or "N/A"}

          [ARCHITECTURE]
          SCORE: {number}/20
          ISSUES:
          - {issue description or "None"}
          RECOMMENDATION: {one-line recommendation or "N/A"}

          [CORRECTNESS]
          SCORE: {number}/20
          ISSUES:
          - {issue description or "None"}
          RECOMMENDATION: {one-line recommendation or "N/A"}

          [PERFORMANCE_DATA]
          SCORE: {number}/20
          ISSUES:
          - {issue description or "None"}
          RECOMMENDATION: {one-line recommendation or "N/A"}

          [SUMMARY]
          TOTAL: {sum of 5 scores}/100
          VERDICT: {PASS if total >= 80, FAIL if total < 80}
          COMMENT: {1-2 sentence overall assessment}

          [REVIEW_END]
          ```

          ### Rules:
          1. Each SCORE MUST be a single integer from 0-20
          2. TOTAL MUST equal the exact sum of the 5 scores
          3. VERDICT MUST be exactly "PASS" or "FAIL" (PASS if TOTAL >= 80, FAIL otherwise)
          4. Every section MUST have at least one ISSUES bullet (use "None" if no issues)
          5. Do NOT add markdown headers (###), bold (**), or any formatting outside this template
          6. The `[REVIEW_START]` and `[REVIEW_END]` tags MUST be present
          7. ISSUES should be concrete and actionable with file paths and line numbers where possible
          8. Use the correct category names for the detected role
          EOF

          {
            echo ""
            echo "---"
            echo "PR number: ${PR_NUMBER}"
            echo "PR title: ${PR_TITLE}"
            echo "PR author: ${PR_AUTHOR}"
            echo "Diff truncated: ${DIFF_TRUNCATED}"
            echo ""
            echo "DIFF:"
          } >> codex_prompt.md
          cat pr.diff >> codex_prompt.md

      - name: Run Codex with selected model
        id: codex_model
        uses: openai/codex-action@v1
        continue-on-error: true
        with:
          openai-api-key: ${{ secrets.CODEX_API_TOKEN }}
          prompt-file: codex_prompt.md
          model: ${{ inputs.model || 'gpt-5.2-codex' }}
          sandbox: read-only
          safety-strategy: drop-sudo
          allow-bots: true

      - name: Run Codex with auto-selected model
        id: codex_auto
        if: ${{ steps.codex_model.outcome != 'success' }}
        uses: openai/codex-action@v1
        continue-on-error: true
        with:
          openai-api-key: ${{ secrets.CODEX_API_TOKEN }}
          prompt-file: codex_prompt.md
          sandbox: read-only
          safety-strategy: drop-sudo
          allow-bots: true

      - name: Prepare review output
        id: call
        env:
          CODEX_FINAL_MESSAGE: ${{ steps.codex_auto.outputs.final-message || steps.codex_model.outputs.final-message }}
          CODEX_OUTCOME: ${{ steps.codex_auto.outcome || steps.codex_model.outcome || 'failure' }}
          CODEX_MODEL_OUTCOME: ${{ steps.codex_model.outcome || 'skipped' }}
          CODEX_AUTO_OUTCOME: ${{ steps.codex_auto.outcome || 'skipped' }}
          REQUESTED_MODEL: ${{ inputs.model || 'gpt-5.2-codex' }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail

          python - <<'PY'
          import os, re

          raw = os.environ.get("CODEX_FINAL_MESSAGE") or ""
          outcome = os.environ.get("CODEX_OUTCOME") or ""
          model_outcome = os.environ.get("CODEX_MODEL_OUTCOME") or ""
          auto_outcome = os.environ.get("CODEX_AUTO_OUTCOME") or ""
          requested_model = os.environ.get("REQUESTED_MODEL") or ""
          run_url = os.environ.get("RUN_URL") or ""

          def fallback(reason: str) -> str:
            reason = reason.strip().replace("\n", " ")
            return "\n".join([
              "[REVIEW_START]",
              "",
              "[SECURITY]",
              "SCORE: 0/20",
              "ISSUES:",
              f"- {reason}",
              "RECOMMENDATION: N/A",
              "",
              "[CODE_QUALITY]",
              "SCORE: 0/20",
              "ISSUES:",
              "- None",
              "RECOMMENDATION: N/A",
              "",
              "[ARCHITECTURE]",
              "SCORE: 0/20",
              "ISSUES:",
              "- None",
              "RECOMMENDATION: N/A",
              "",
              "[CORRECTNESS]",
              "SCORE: 0/20",
              "ISSUES:",
              "- None",
              "RECOMMENDATION: N/A",
              "",
              "[PERFORMANCE_DATA]",
              "SCORE: 0/20",
              "ISSUES:",
              "- None",
              "RECOMMENDATION: N/A",
              "",
              "[SUMMARY]",
              "TOTAL: 0/100",
              "VERDICT: FAIL",
              "COMMENT: Codex review failed to produce a valid report.",
              "",
              "[REVIEW_END]",
              "",
            ])

          def is_valid_template(s: str) -> tuple[bool, str]:
            if "[REVIEW_START]" not in s or "[REVIEW_END]" not in s:
              return False, "Missing [REVIEW_START]/[REVIEW_END] tags"
            # Extract 5 category scores
            score_re = re.compile(r"^SCORE:\s*(\d{1,2})/20\s*$", re.MULTILINE)
            scores = [int(x) for x in score_re.findall(s)]
            if len(scores) < 5:
              return False, f"Expected 5 SCORE lines, found {len(scores)}"
            scores = scores[:5]
            if any(x < 0 or x > 20 for x in scores):
              return False, "Score out of range"

            m_total = re.search(r"^TOTAL:\s*(\d{1,3})/100\s*$", s, re.MULTILINE)
            if not m_total:
              return False, "Missing TOTAL line"
            total = int(m_total.group(1))
            if total != sum(scores):
              return False, f"TOTAL mismatch (got {total}, expected {sum(scores)})"

            m_verdict = re.search(r"^VERDICT:\s*(PASS|FAIL)\s*$", s, re.MULTILINE)
            if not m_verdict:
              return False, "Missing VERDICT line"
            verdict = m_verdict.group(1)
            expected = "PASS" if total >= 80 else "FAIL"
            if verdict != expected:
              return False, f"VERDICT mismatch (got {verdict}, expected {expected})"

            return True, ""

          if not raw.strip():
            if requested_model:
              reason = f"Codex produced no output. requested_model={requested_model}, model_outcome={model_outcome}, auto_outcome={auto_outcome}, outcome={outcome}. Logs: {run_url}"
            else:
              reason = f"Codex produced no output. auto_outcome={auto_outcome}, outcome={outcome}. Logs: {run_url}"
            out = fallback(reason)
            ok = False
          else:
            valid, why = is_valid_template(raw)
            if not valid:
              out = fallback(f"Codex output invalid: {why}. Logs: {run_url}")
              ok = False
            else:
              out = raw.strip() + "\n"
              ok = True

          open("comment.md", "w", encoding="utf-8").write(out)
          open(os.environ.get("GITHUB_OUTPUT"), "a", encoding="utf-8").write(f"api_ok={'true' if ok else 'false'}\n")
          PY

      - name: Post PR comment
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          owner="${{ github.repository_owner }}"
          repo="$(echo "${{ github.repository }}" | cut -d/ -f2)"
          pr="${{ github.event.pull_request.number }}"

          python - <<'PY' > body.json
          import json
          body = open("comment.md", "r", encoding="utf-8", errors="replace").read()
          print(json.dumps({"body": body}))
          PY

          curl -sS -L \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Content-Type: application/json" \
            -d @body.json \
            "https://api.github.com/repos/${owner}/${repo}/issues/${pr}/comments" \
            > /dev/null

      - name: Fail job if Codex failed
        if: ${{ steps.call.outputs.api_ok != 'true' }}
        run: |
          set -euo pipefail
          echo "Codex review failed. See the PR comment and job logs for details." >&2
          exit 1
